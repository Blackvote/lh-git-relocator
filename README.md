# GL Migrator

Утилита, которая, на основе репозитория созданного в GitLab, создаёт репозиторий в GitHub и переносит в него доступные данные. 

## Подготовка к запуску

**warn:** Существует прямая зависимость от Git на устройстве.  
**info:** Некоторые команды запускаются путём передачи в консоль команды типа "git clone --bare URL".  
**info:** Убедитесь что Git установлен и находится в PATH.  
**info:** Для работы нужно 2 конфига, один для работы программы (создаст утилита) и один для миграции (инфо по репозиторию и секреты), создаётся руками  
**warn:** Утилита не работает с SSH урлами до репозиториев  

1. Создать GL и GH токены.
2. Создать пустую папку.
3. Закинуть в пустую папку бинарь.
4. Создать конфиг "config.yml".
5. После обработки репозитория, в домашней директории будет создан файл "progress.json" со списком обработанных MR'ов со статус-кодами ответов.
6. Известные статус-коды:  
  6.1. 200 - PR был создан  
  6.2. 403 - Достигнут лимит обращений к API. Создание контента заблокированно. PR не был создан  
  6.3. 404 - Не найдена какая-то из веток. PR не был создан  
  6.4. 422 - Ошибка валидатора API. PR не был создан  

## Конфиг репозитория "config.yml"
```
repo: # конфиг создания репозитория в GH
  source: <source_url> # ссылка на GL репозиторий
  organization: <GH_organization> # GH организация
  repoName: <GH_repoName> # Название репозитория, который будет создан\найден в GH
  topics: <topics_list> # Топики, которые будет добавлены при создании репозитория. Разделитель `,`: exampleTopic, exampleTopic2, exampleTopic3
secret:  # <secret_map> мапа с перечислением key: value секретов которые будет созданы\перезаписанны для репозитория.
  exampleName: exampleValue
  exampleName2: exampleValue2 
# secretOnlyMode: true # Если раскомментировать, то утилита только создаст\обновит секреты
```

## Алгоритм работы приложения:

1. Проверяет GL и GH Токены. Если их нет - запрашивает и сохраняет в gl-migrator-cfg.yaml (Приложение само создаёт свой конфиг).
2. Ищет в GH репозиторий на основе <GH_repoName>.
  2.1.Если не найден - создаётся + добавляются топики из <topics_list>.
3. Создаются секреты из <secret_map>.
4. Отчищает папку (".").
5. Клонирует репу из source.
6. Переименовывает клонированную папку в .git.
7. Меняет <source_url> на созданный в GH репозиторий.
8. Пушит в origin. RefSpec 'refs/heads/*:refs/heads/*' ( все ветки ).
9. Получает список MR из GitLab.
10. Переименовывает клонированную папку в .git.
11. Читает файл progress.json.
  11.1. Проверяет projectID полученный из Gitlab и из файла, если не сходтся, файл игнорируется и перезаписывается..
  11.2. Если файл валидный, обрабатываются те MR'ы, которые в стейте имеют статус код - 403.
12. Получает список PR из GitHub.
13. Получает список Tags из GitLab.
14. Мигрирует MR'ы.
15. При необходимости записывает status code от запросов на создание PR в progress.json.
16. Мигрирует Issue's.
17. Мигрирует Tags.

### State алгоритм (сыро)
1. Читается файл progress.json в домашней директории, если его нет, создаётся, дальше игнорируется.
2. Если файл был прочитан, собирается переменная со стейтом.
  2.1. Обрабатываются только те MR, которые в стейте вернули 403 статус код.
3. Мигрируются все полученные из GL MR'ы, записываются Status Code из ответа от API.
4. Если файл не был прочитан (пуст, бит, не тот проект), переменная со стейтом записывается в файл.

### Цикл обработки Merge Request'a, с целью создания из него PR, приложение:
1. Проверяет список PR'ов на наличие в нём PR с именем MR (проверяем что создаваемый PR не создан ранее, чтобы не дублировать).
2. Проверяет что Merge Branches существуют.
3. Создаёт PR.
4. Получает список лейбла из MR.
5. Проверяет их наличие в создаваемом PR, если их нет, проверяет существуют ли они, если нет, создаёт.
6. Добавляет лейблы на PR.
7. Добавляет комментарий в PR main.go#L588
8. Собирает из полученных, в ответах от GH API, status Code файл progress.json для избежания попыток повторных созданий не создающихся PR  .

P.S - если после MR'a, в GL была удалена одна из веток, GH не даст создать PR

### Цикл обработки Issue's
1. Запрашивает все Issues по ProjectID из GitLab
2. Запрашивает все Issues по RepoName из GitHub
3. Сравнивает каждую Issue из Gitlab с Issues из Github, по Tittle, state, если есть совпадение - пропускает  
  3.1 Если не совпадает state, редактирует state для Issue в GitHub  
  3.2 GitHub API не различает PR и Issues. Отсеивание PR происходит по сравниванию HTMLURL свойства. У PR оно = pulls, у Issues оно = issues  
4. Создаёт переменную NewIssue
5. Отправляет NewIssue в GitHub API

### Цикл обработки Tags
1. Достаёт из GitLab Tag Имя, сообщение, commit_sha, Автора, дату создания, почту.
2. На основе данных полученных из GitLab Tag создаёт GitHub Tag
3. Создаёт ссылку на Tag. Если такая ссылка уже есть, пропускает

### Цикл создания Секретов
1. Получаем Public_key
2. На основе данных из конфига, циклом отправляет запросы в GH API на создание\обновление секрета

## NB

Если PRов много, то можно упереться в Rate Limit от GitHub, ( Как правило допустимо пушить 8 PR за раз ) ошибка:  
403 You have exceeded a secondary rate limit and have been temporarily blocked from content creation. Please retry your request again later. []  
Что делать? Ждать. И пробовать ещё